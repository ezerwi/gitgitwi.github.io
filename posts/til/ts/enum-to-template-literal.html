<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/dc7677ea01a8b939.css" as="style"/><link rel="stylesheet" href="/_next/static/css/dc7677ea01a8b939.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-69bfa6990bb9e155.js" defer=""></script><script src="/_next/static/chunks/framework-e70c6273bfe3f237.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-2cddac7da4092d4b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/til/ts/enum-to-template-literal-410432a7261f89d5.js" defer=""></script><script src="/_next/static/GssA4mdH8bXsPSxnrIqYt/_buildManifest.js" defer=""></script><script src="/_next/static/GssA4mdH8bXsPSxnrIqYt/_ssgManifest.js" defer=""></script><script src="/_next/static/GssA4mdH8bXsPSxnrIqYt/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><h1>[TypeScript]<!-- --> <code>enum</code> -&gt; <code>literal</code> 타입 갈아타기(+<code>class-validator</code>, <code>template literal</code> 타입 활용)</h1><h3>3줄 요약</h3><blockquote><ul><li><code>enum</code>은 tree-shaking, memory-leak 문제가 있고, 여러 enum을 하나의 enum으로 합칠 수 없다</li><li><code>class-validator</code>에서 <code>IsEnum</code>을 쓰려면, 타입이 아닌 객체가 필요하다</li><li><code>literal</code>과 <code>Readonly&lt;Record&lt;K, V&gt;&gt;</code> 유틸 타입을 활용해 문제를 해결했다</li></ul></blockquote><p><a href="https://wiii.hashnode.dev/enum-to-template-literal">👉 hashnode에서 보기</a></p><hr/><h2><code>enum</code>은 비싸고 불편하다!</h2><p>다른 언어들과 마찬가지로 <code>TypeScript</code>도 열거형 타입으로 <a href="https://www.typescriptlang.org/ko/docs/handbook/enums.html"><code>enum</code></a>을 제공한다</p><p>함수 인자로 특정 string만 들어와야 하는 경우 등 유용하게 쓸 수 있다</p><br/><h3>Tree-shaking, 메모리 문제</h3><p>그러나 Line 기술 블로그(<a href="https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/">&#x27;TypeScript enum을 사용하지 않는 게 좋은 이유를 Tree-shaking 관점에서 소개합니다.&#x27;</a>)에서 잘 설명하는 것처럼, 순진한 enum 타입은 tree-shaking이 안되고 메모리 낭비까지 이어질 수 있다.</p><br/><h3>예상과는 다른 Type Union</h3><p>무엇보다 개인적으로 가장 불편하게 느껴지는 것은 다른 타입들과는 다르게, <strong><em>enum은 <code>union</code>으로 여러 enum을 하나로 합칠 수 없다는 점이다</em></strong></p><p>아래 예시 코드는 실무에서 구현 중인 API 타입 일부를 조금 수정해서 가져온 것이고, 전형적인 enum을 가져왔다</p><pre><code class="language-typescript">enum PeriodA {
  DAILY = &#x27;DAILY&#x27;,
  MONTHLY = &#x27;MONTHLY&#x27;
}

enum PeriodCommon {
  WEEKLY = &#x27;WEEKLY&#x27;,
  QUARTERLY = &#x27;QUARTERLY&#x27;,
  YEARLY = &#x27;YEARLY&#x27;
}
</code></pre><p><a href="https://www.typescriptlang.org/ko/docs/handbook/2/everyday-types.html#%EC%9C%A0%EB%8B%88%EC%96%B8-%ED%83%80%EC%9E%85">Union Type</a>을 쓰는 대부분은 아래처럼 A 타입 일수도 있고, B 타입일 수도 있을 때이다</p><pre><code class="language-typescript">type StringOrNumber = string | number;

const strOrNumberLogger = (what: StringOrNumber) =&gt; console.log(what);
strOrNumberLogger(&#x27;asdf&#x27;);
strOrNumberLogger(123123);
</code></pre><br/><p><strong><em>그러나 이 넘의 enum은 그렇지 않다</em></strong> </p><p><code>PeriodA</code>와 <code>PeriodCommon</code>를 합친 <code>Periods</code>라는 enum을 만들고 싶지만 그 과정은 쉽지 않다</p><p>아래처럼 타입 Union을 하면 당장은 에러가 나진 않지만, 실질적으로는 사용할 수 없는 타입이 된다</p><pre><code class="language-typescript">type Periods = PeriodA | PeriodCommon;

const periodLogger = (period: Periods) =&gt; console.log(period);
periodLogger(&#x27;DAILY&#x27;); // error
</code></pre><br/><p>Intersection은 더더욱 안된다</p><p>둘 사이에 공통점이 없기 때문에 <strong><code>never</code></strong> 타입이 된다</p><pre><code class="language-typescript">type Periods = PeriodA &amp; PeriodCommon; // -&gt; never

const periodLogger = (period: Periods) =&gt; console.log(period);
periodLogger(&#x27;DAILY&#x27;); // error
</code></pre><br/><p>타입 assertion으로 에러를 안낼 수는 있는데..<strong><em>아무 의미 없는 타입 선언</em></strong>이 되어 버린다</p><p><img src="https://images.velog.io/images/johnwi/post/669de5ad-34fb-4a23-b86e-a8cb8ea5326a/image.png"/></p><br/><hr/><h2><code>class-validator</code>의 <code>IsEnum</code>을 쓰려면 객체가 필요하다!</h2><p>가장 속 편한건 단순히 <code>literal</code>&#x27;만&#x27; 쓰는 거다</p><p>토스 기술 블로그 <a href="https://toss.tech/article/template-literal-types">Template Literal Types로 타입 안전하게 코딩하기</a>에서 소개하는 것처럼, </p><p>TypeScript에는 문자열을 가지고 다양한 타입을 만들어 낼 수 있는 재미있는(?) 기능이 있다</p><br/><p>다만 위에서 예시로 가져온 <code>Periods</code>는 단순히 함수 인자의 타입만 추론하는데 쓰는 것이 아니라,</p><p>아래와 같이 <strong><a href="https://github.com/typestack/class-validator"><code>class-validator</code></a>를 활용해 API 요청 유효성 검사</strong>에도 사용될 수 있어야했다</p><pre><code class="language-typescript">export class GetChartDto {
  @IsNotEmpty()
  @IsEnum(Periods)
  period: PeriodNames;
}
</code></pre><br/><p>당연한 거지만, 아래와 같이 type을 함수 인자로 넣을 수는 없다</p><p><img src="https://images.velog.io/images/johnwi/post/515a911a-181d-4730-8f15-610f6dc508a3/image.png"/></p><br/><p>위 라인 블로그에서 가장 추천하는 방법은 객체를 가지고 Union 타입을 만드는 것이다</p><p>enum으로 union 만들 방법을 구글링(<code>&#x27;typescript enum union&#x27;</code>)하면 나에게 가장 먼저 뜨는 글인</p><p>정규현님의 <a href="https://ajdkfl6445.gitbook.io/study/typescript/enum-type-union-type">enum type 대신 union type으로 변경하기</a>에서도 그 방식을 개선하여 사용한 경험을 보여주고 있다</p><p>여기서 핵심은 아래와 같다</p><pre><code class="language-typescript">const READONLY_객체 = 객체 as const;
type enumLike = keyof READONLY_객체[keyof typeof READONLY_객체]
</code></pre><p>짧고 유용한 코드지만, 부족한 나에게는 이게 뭘 의미하는지 한번에 파악하기가 조금 어렵다고 느껴졌다</p><p>다만 <code>Readonly</code> 타입을 사용한다는 점에서 힌트를 얻을 수 있었다 </p><p><em>(이게 꼭 필요한 건지는 아직 테스트를 안해봤다...)</em></p><br/><h2><em>(적어도 나에게는)</em> 좀더 편한 방법!</h2><p>결론은 아래와 같다</p><pre><code class="language-typescript">// periods.ts
type ReadonlyRecord&lt;K extends string, V&gt; = Readonly&lt;Record&lt;K, V&gt;&gt;;

export type PeriodANames = &#x27;DAILY&#x27; | &#x27;MONTHLY&#x27;;
export const PeriodA: ReadonlyRecord&lt;PeriodANames, PeriodANames&gt; = {
  DAILY: &#x27;DAILY&#x27;,
  MONTHLY: &#x27;MONTHLY&#x27;,
};

type PeriodCommonNames = &#x27;WEEKLY&#x27; | &#x27;QUARTERLY&#x27; | &#x27;YEARLY&#x27;;
const PeriodCommon: ReadonlyRecord&lt;PeriodCommonNames, PeriodCommonNames&gt; = { /** */ }

export type PeriodNames = PeriodANames | PeriodCommonNames;
export const Periods = { ...PeriodA, ...PeriodCommon };
</code></pre><br/><h3>커스텀 유틸 타입 <code>ReadonlyRecord</code></h3><p>이 부분은 반드시 필요한 부분은 아니고, 개인적으로 객체를 <code>Reaonly</code>로 만드는 경우가 많아 따로 선언했다</p><p>실무 코드에서는 좀더 편한 코딩을 위해 끼를 부려서 아래와 같이 선언했다</p><p>객체 <code>key</code>, <code>value</code>가 모두 <code>string</code>인 경우에는 기본값 덕분에 제네릭을 생략할 수 있고, </p><p><code>string</code>은 아니지만 <code>key</code>, <code>value</code>가 동일한 타입인 경우는 하나만 적어주면 된다</p><pre><code class="language-typescript">export type ReadonlyRecord&lt;P extends string = string, Q = P&gt; = Readonly&lt;Record&lt;P, Q&gt;&gt;;

export const PeriodA: ReadonlyRecord&lt;PeriodANames&gt; = { /** */ }
</code></pre><br/><h3><code>literal</code> 타입; <code>PeriodNames</code>, <code>_RestPeriodNames</code></h3><p>단순한 문자열 literal 타입이다</p><p>Union이라는 의미에 맞게, <strong><em>관심사에 따라 분리된 타입들을 하나로 묶는 것이 쉽다</em></strong></p><p><code>keyof typeof 객체</code>를 대신하기 위해 타입을 하나하나 더 써야한다는 것이 단점이기는 하지만,</p><p>아래 객체를 생성할 때 자동완성이 되기 때문에 크게 불편함을 느끼진 않을수 있다</p><p>오히려 하나의 타입에 너무 많은 속성이 있어서 타이핑 시간이 오래 걸릴 정도라면, 타입을 충분히 분리하지 못한 게 아닐지 검토해봐야 할 것 같다</p><p>또 토스 블로그에서 소개한 것처럼, <strong><code>template-literal</code> 타입들을 조합한 새로운 타입들을 선언하기 매우 편리해진다</strong></p><pre><code class="language-typescript">export type MarketNames = &#x27;domestic&#x27; | &#x27;overseas&#x27;;
export type CategoryNames = &#x27;index&#x27; | &#x27;stock&#x27;;

export type DetailChartTypeNames = `${MarketNames}-${CategoryNames}`;
export const DetailChartTypes: ReadonlyRecord&lt;DetailChartTypeNames&gt; = {
  &#x27;domestic-index&#x27;: &#x27;domestic-index&#x27;,
  &#x27;domestic-stock&#x27;: &#x27;domestic-stock&#x27;,
  &#x27;overseas-index&#x27;: &#x27;overseas-index&#x27;,
  &#x27;overseas-stock&#x27;: &#x27;overseas-stock&#x27;,
};
</code></pre><br/><h3>Readonly 객체를 <code>class-validator IsEnum</code>에 활용</h3><pre><code class="language-typescript">// get-chart-dto.ts
export class GetChartDto {
  @IsNotEmpty()
  @IsEnum(Periods)
  period: PeriodNames;
}
</code></pre><p><code>literal</code>을 활용하여 안전한(type-safe) <code>Readonly</code> 객체를 만들고, <code>class-validator</code>에서 활용한다</p><p><code>class-validator</code>가 아니더라도, 기존 <code>enum</code> 사용하듯 <code>Periods.DAILY</code>와 같이 사용할 수도 있다</p><p>JS로 Transpile 되었을때, 단순 객체 리터럴이기 때문에 라인 블로그대로라면 tree-shaking도 가능하다</p></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/posts/til/ts/enum-to-template-literal","query":{},"buildId":"GssA4mdH8bXsPSxnrIqYt","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>